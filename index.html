<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Slope â€” JS clone</title>
<style>
  html,body { height:100%; margin:0; background:#111; color:#ddd; font-family:system-ui,Segoe UI,Roboto,Arial; }
  #game { display:block; margin:0 auto; background:#101014; touch-action:none; }
  .hud {
    position:fixed; left:12px; top:12px; font-weight:600; letter-spacing:0.5px;
    background:rgba(0,0,0,0.25); padding:8px 10px; border-radius:8px;
  }
  .center {
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); text-align:center;
    color:#fff;
  }
  button { padding:8px 12px; font-size:16px; border-radius:6px; border:0; cursor:pointer; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hud" id="hud">Score: 0</div>
<div class="center" id="overlay" style="display:none">
  <h1 id="overlay-title">Game Over</h1>
  <p id="overlay-sub">Score: 0</p>
  <button id="restart-btn">Play Again</button>
</div>

<script>
/*
  Slope-like game (single-file).
  - Procedural obstacles in 3D (z-depth), projected onto 2D canvas for perspective.
  - Player is a ball near bottom that moves left/right.
  - Obstacles are blocks (some deadly), some gaps.
  - Controls: ArrowLeft/ArrowRight or A/D. Touch to drag.
*/

(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  const hud = document.getElementById('hud');
  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlay-title');
  const overlaySub = document.getElementById('overlay-sub');
  const restartBtn = document.getElementById('restart-btn');

  // high-DPI handling
  function resize() {
    const w = Math.max(320, Math.min(innerWidth, 1400));
    const h = Math.max(480, innerHeight);
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener('resize', resize, { passive: true });
  resize();

  // Game constants & state
  const state = {
    running: false,
    score: 0,
    speed: 12,         // base forward speed (z units per second)
    speedUpRate: 0.0018, // how fast speed increases per ms
    playerX: 0,        // world x (-1 .. 1)
    playerSpeed: 2.6,  // lateral speed (world units per second)
    obstacles: [],
    lastSpawnZ: 0,
    spawnIntervalZ: 18, // spawn every z distance
    zMax: 300,         // max z (far)
    fov: 300,          // focal length for projection
    lanes: 5,          // conceptual lanes (used for obstacle placement)
    time: 0,
    lastTime: performance.now(),
    inputLeft: false,
    inputRight: false,
    touch: {active:false, startX:0},
    gameOver: false
  };

  // Utility: linear map
  const lerp = (a,b,t) => a + (b-a)*t;

  // Obstacle factory
  function spawnObstacle(z) {
    // obstacle width in world units (x range -1..1)
    // sometimes create a gap, sometimes a block across
    const kind = Math.random() < 0.78 ? 'block' : 'hole'; // hole = gap you must steer into
    // Choose lane center
    const lane = Math.floor(Math.random() * state.lanes);
    const laneWidth = 2 / state.lanes;
    const center = -1 + laneWidth*(lane + 0.5);
    const width = laneWidth * (0.8 + Math.random()*0.6);
    // height extent in z (thickness)
    const depth = 6 + Math.random()*8;
    const color = kind === 'block' ? '#e23b3b' : '#222'; // holes are just absence
    const obstacle = { z, depth, kind, center, width, color };
    state.obstacles.push(obstacle);
  }

  function resetGame() {
    state.running = true;
    state.score = 0;
    state.speed = 12;
    state.playerX = 0;
    state.obstacles = [];
    state.lastSpawnZ = 0;
    state.time = 0;
    state.lastTime = performance.now();
    state.gameOver = false;
    overlay.style.display = 'none';
    // pre-spawn a bunch of obstacles
    for (let z = 40; z < state.zMax; z += state.spawnIntervalZ) {
      spawnObstacle(z + Math.random()*6);
    }
  }

  // Project a world point (x, z) to screen coords.
  function project(x, z) {
    // world x range -1..1 maps to screen width centered
    const f = state.fov;
    const scale = f / (z + f);
    const sx = canvas.width / (window.devicePixelRatio || 1) / 2 + x * (canvas.width / (window.devicePixelRatio || 1) / 2) * scale;
    // y: closer z -> lower (near bottom). We map z to a vertical screen coordinate so that z=0 near bottom.
    const sy = lerp(canvas.height / (window.devicePixelRatio || 1) * 0.15, canvas.height / (window.devicePixelRatio || 1) * 0.9, 1 - (z / state.zMax));
    return { x: sx, y: sy, scale };
  }

  // Collision detection: approximate obstacle as rectangle projected, player as circle
  function checkCollision(ob) {
    // project near face (z at ob.z - ob.depth/2) with a few samples to increase reliability
    const samples = 3;
    const playerScreen = project(state.playerX, 2); // player's depth ~ 2 (small positive)
    const playerR = 12; // screen radius
    for (let s=0; s<samples; s++) {
      const zSample = ob.z - ob.depth * (s / (samples-1));
      if (zSample <= 0) continue; // behind player
      const p = project(ob.center, zSample);
      const halfW = (ob.width / 2) * (canvas.width / (window.devicePixelRatio || 1) / 2) * p.scale;
      const halfH = 20 * p.scale + 6; // vertical block thickness projected
      const left = p.x - halfW, right = p.x + halfW;
      const top = p.y - halfH, bottom = p.y + halfH;
      // circle-rect collision
      const cx = Math.max(left, Math.min(playerScreen.x, right));
      const cy = Math.max(top, Math.min(playerScreen.y, bottom));
      const dx = playerScreen.x - cx, dy = playerScreen.y - cy;
      if (dx*dx + dy*dy <= playerR*playerR) return true;
    }
    return false;
  }

  // Game loop
  function update(dt) {
    if (!state.running) return;
    state.time += dt;
    // forward movement: move obstacles toward player by reducing their z
    const dz = state.speed * (dt / 1000);
    for (let ob of state.obstacles) ob.z -= dz;
    // remove obstacles that passed behind
    state.obstacles = state.obstacles.filter(ob => ob.z > -10);

    // spawn new obstacles to keep density
    while (state.obstacles.length < Math.ceil(state.zMax / state.spawnIntervalZ) + 6) {
      const nextZ = state.lastSpawnZ + state.spawnIntervalZ + Math.random()*6;
      state.lastSpawnZ = nextZ;
      spawnObstacle(state.zMax + Math.random()*30 + nextZ*0.02);
    }

    // speed up slightly over time
    state.speed += state.speedUpRate * dt;

    // handle lateral input
    const left = state.inputLeft ? 1 : 0;
    const right = state.inputRight ? 1 : 0;
    const axis = right - left;
    state.playerX += axis * state.playerSpeed * (dt / 1000);
    // clamp playerX to world bounds (-1 .. 1)
    state.playerX = Math.max(-1.1, Math.min(1.1, state.playerX));

    // update score (score increases as you travel)
    state.score += Math.floor(dz * 10);
    hud.textContent = 'Score: ' + Math.max(0, Math.floor(state.score));

    // collisions
    for (let ob of state.obstacles) {
      // only check obstacles within a "danger zone" near player
      if (ob.z < 60 && ob.z > 0) {
        if (ob.kind === 'block' && checkCollision(ob)) {
          // hit block -> game over
          state.running = false;
          state.gameOver = true;
          overlayTitle.textContent = 'Game Over';
          overlaySub.textContent = 'Score: ' + Math.max(0, Math.floor(state.score));
          overlay.style.display = 'block';
          break;
        }
        // holes: if obstacle is hole type, it's an opening that if you are inside it you survive; if you're not centered and there's a block elsewhere, it's handled as blocks
      }
    }
  }

  function draw() {
    // clear
    const W = canvas.width / (window.devicePixelRatio || 1);
    const H = canvas.height / (window.devicePixelRatio || 1);
    ctx.fillStyle = '#0b0b0d';
    ctx.fillRect(0,0,W,H);

    // draw ground / gradient
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, '#121218');
    g.addColorStop(1, '#0b0b0d');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // draw central road perspective guides (subtle)
    ctx.save();
    ctx.globalAlpha = 0.12;
    for (let i=0; i<30; i++) {
      const z = i * (state.zMax / 30);
      const p = project(0, z);
      const width = (W * 0.18) * (state.fov / (z + state.fov));
      ctx.fillStyle = i % 2 ? '#00aab6' : '#00aab6';
      ctx.fillRect(p.x - width/2, p.y - 4, width, 8);
    }
    ctx.restore();

    // draw obstacles sorted by z far->near (so near ones draw over far ones)
    const obstacles = state.obstacles.slice().sort((a,b) => b.z - a.z);
    for (let ob of obstacles) {
      if (ob.z <= 0) continue; // behind
      const pNear = project(ob.center, ob.z - ob.depth/2);
      const pFar = project(ob.center, ob.z + ob.depth/2);
      const widthNear = (ob.width / 2) * (W/2) * pNear.scale * 2;
      const widthFar = (ob.width / 2) * (W/2) * pFar.scale * 2;
      // draw trapezoid to simulate 3D block
      ctx.beginPath();
      ctx.moveTo(pFar.x - widthFar/2, pFar.y);
      ctx.lineTo(pFar.x + widthFar/2, pFar.y);
      ctx.lineTo(pNear.x + widthNear/2, pNear.y);
      ctx.lineTo(pNear.x - widthNear/2, pNear.y);
      ctx.closePath();
      if (ob.kind === 'block') {
        ctx.fillStyle = ob.color;
        ctx.fill();
        // rim
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 1;
        ctx.stroke();
      } else {
        // hole: draw a darker patch that looks like a gap
        ctx.fillStyle = '#060607';
        ctx.fill();
      }
    }

    // draw player ball near bottom
    const playerScreen = project(state.playerX, 2); // player very near
    const pr = 12;
    // shadow
    ctx.beginPath();
    ctx.ellipse(playerScreen.x, playerScreen.y + 14, pr*1.4, pr*0.6, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fill();
    // ball
    const grad = ctx.createRadialGradient(playerScreen.x-6, playerScreen.y-8, 2, playerScreen.x, playerScreen.y, pr*1.6);
    grad.addColorStop(0, '#fff');
    grad.addColorStop(0.15, '#9ee8ff');
    grad.addColorStop(1, '#36a0e0');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(playerScreen.x, playerScreen.y, pr, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = 1.2;
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.stroke();

    // subtle HUD in bottom-right
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.fillRect(W-220, H-82, 200, 66);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(W-220, H-82, 200, 2);
  }

  function loop(now) {
    const dt = now - state.lastTime;
    state.lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // Input handling
  addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') state.inputLeft = true;
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') state.inputRight = true;
    // space to restart if game over
    if (e.key === ' ' && state.gameOver) {
      resetGame();
    }
  });
  addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') state.inputLeft = false;
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') state.inputRight = false;
  });

  // mouse / touch input: drag left/right
  let dragging = false;
  canvas.addEventListener('pointerdown', (ev) => {
    dragging = true;
    canvas.setPointerCapture(ev.pointerId);
    state.touch.active = true;
    state.touch.startX = ev.clientX;
  });
  canvas.addEventListener('pointermove', (ev) => {
    if (!dragging) return;
    // map pointer delta to world x
    const dx = (ev.clientX - state.touch.startX) / (canvas.clientWidth || 1);
    state.playerX += dx * 2.2; // sensitivity
    state.touch.startX = ev.clientX;
    state.playerX = Math.max(-1.1, Math.min(1.1, state.playerX));
  });
  canvas.addEventListener('pointerup', (ev) => {
    dragging = false;
    state.touch.active = false;
  });
  canvas.addEventListener('pointercancel', () => {
    dragging = false;
    state.touch.active = false;
  });

  // restart button
  restartBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    resetGame();
  });

  // start
  resetGame();
  requestAnimationFrame(loop);

  // expose for debugging (optional)
  window._slopeState = state;
})();
</script>
</body>
</html>
